Process
==========

### 운영체제
> Operating System

> 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공하는 시스템 소프트웨어

> Ex) windows, mac os, Linux

> 실행되는 응용 프로그램들이 메모리와 CPU, 입출력 장치 등의 자원들을 사용할 수 있도록 도움

### 프로그램

> 어떤 작업을 위해 실행할 수 있는 파일

### 프로세스 

> 컴퓨터에서 연속적으로 실행되고 있는 프로그램

![image](https://user-images.githubusercontent.com/94096054/147028244-8c126619-5a85-42cb-9443-583699d3434d.png)

  + 동적인 개념으로는 실행된 프로그램을 의미
  + 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것
  + 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
  + 운영체제로부터 시스템 자원(주소 공간, 파일, 메모리)을 할당받는 작업의 단위
  + 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역변수들을 수록하는 데이터 섹션을 포함
  + 프로세스 실행 중에 동적으로 할당되는 메모리인 메모리 힙 포함
  + 프로그램 vs 프로세스
    - 프로그램은 명령어를 내용으로 가진 디스크에 저장된 파일(수동적)
    - 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련된 자원의 집합을 가진 존재(능동적)
    - 실행 파일이 메모리에 적재될 때 프로그램이 프로세스가 되는 것(객체와 인스턴스와 유사)
  
#### 할당받는 자원의 예

* CPU 시간
* 운영되기 위해 필요한 주소 공간
* Code, Data, Stack, Heap의 구조로 되어있는 독립적인 메모리 영역

#### 특징

* 프로세스는 각각의 독립적인 메모리 영역(Code, Data, Stack, Heap의 구조)를 할당
  
  + Code: 프로그램을 실행시키는 실행 파일 내의 명령어(소스코드)
  + Data: 전역변수, static 변수의 할당
  + Heap: 동적할당을 위한 메모리 영역
  + Stack: 지역변수, 함수 호출 시 전달되는 파라미터, 함수 리턴시 리턴 값 및 리턴 주소 

* 각 프로세스는 별도의 주소 공간에서 실행, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음

* 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process Communication)을 사용
  
  + 파이프, 파일, 소켓 등을 사용

#### 상태

![image](https://user-images.githubusercontent.com/94096054/147029587-053207b0-1e5c-4700-b41b-feded48ab36a.png)

* new: 프로세스가 처음 생성 되었을 때
* ready: 프로세서에게 할당 되기를 기다리는 상태
* running: 프로세서에 할당되어 실행되는 상태, CPU자원을 차지하고 있음
* waiting or blocked: 작업이 완료되어 입출력을 기다리는 상태
* terminated: 실행이 종료되어 프로세스 모드가 끝난 상태 


#### 프로세스 제어 블록(PCB)

> 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조

![image](https://user-images.githubusercontent.com/94096054/147029982-c995a75f-5a8a-4c34-8f5a-5a7fecf8a039.png)


+ 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성
+ 프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스의 전환이 발생하면 진행하던 작업을 저장하고 CPU를 받환, 이때의 모든 작업을 PCB에 저장
+ 다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행
-> Context Switching

* 저장되는 정보 
  + PID(프로세스 식별자) : 프로세스 식별 번호
  + Process State(프로세스 상태): new, ready, running, waiting, terminated 등의 상태를 저장
  + Program Counter(PC): 프로세스가 실행할 다음 명령어의 주소
  + CPU 레지스터
  + CPU 스케줄링 정보: 프로세스의 우선순의, 스케줄 큐에 대한 포인터 등
  + 메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보
  + 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  + 회계 정보: 사용된 CPU양과 시간, 시간 제한, 계정 번호 등
  
  
####  프로세스 간 통신(IPC, Interprocess Communication)

> 서로 다른 두 개의 프로세스가 정보를 주고 받는 방식

> 실행중인 다른 프로세스들에게 영향을 주거나 받지 않는 독립적인 프로세스, 다른 프로세스들에게 영향을 주거나 받는 협력적인 프로세스가 존재

> IPC 기법을 통해 협력적인 프로세스들은 데이터와 정보를 교환

* Ex) Pipe, Named Piped, Message Queue, Shared Memory, Memory Map, Socket, Semaphore

* 공유 메모리 시스템

> 기본적으로 프로세스는 서로의 영역에 침범할 수 없지만 프로세스가 이 제약조건을 제거하는 것에 동의하고 공유 영역에 글을 써 정보를 교환하는 방식

> 공유 메모리 세그먼트를 생성하는 프로세스의 주소공간에 위치시켜 통신하고자 하는 다른 프로세스들이 이 세그먼트를 자신의 주소공간에 추가하는 방법으로 사용

> 동시에 공유 버퍼를 접근하는 상황 때문에 동기화를 고려

* 메세지 전달 시스템

> 커널을 통해 메세지를 교환하기 때문에 별도의 코드를 구축할 필요학 없어 구현이 쉽지만 Context Switching이 발생하기 때문에 속도가 느리다는 단점이 존재




  
  
  
  
  





























