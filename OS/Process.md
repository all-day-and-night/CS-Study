Process
==========

### 운영체제
> Operating System

> 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공하는 시스템 소프트웨어

> Ex) windows, mac os, Linux

> 실행되는 응용 프로그램들이 메모리와 CPU, 입출력 장치 등의 자원들을 사용할 수 있도록 도움

### 프로그램

> 어떤 작업을 위해 실행할 수 있는 파일

### 프로세스 

> 컴퓨터에서 연속적으로 실행되고 있는 프로그램

![image](https://user-images.githubusercontent.com/94096054/147028244-8c126619-5a85-42cb-9443-583699d3434d.png)

  + 동적인 개념으로는 실행된 프로그램을 의미
  + 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것
  + 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
  + 운영체제로부터 시스템 자원(주소 공간, 파일, 메모리)을 할당받는 작업의 단위
  + 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역변수들을 수록하는 데이터 섹션을 포함
  + 프로세스 실행 중에 동적으로 할당되는 메모리인 메모리 힙 포함
  + 프로그램 vs 프로세스
    - 프로그램은 명령어를 내용으로 가진 디스크에 저장된 파일(수동적)
    - 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터 및 관련된 자원의 집합을 가진 존재(능동적)
    - 실행 파일이 메모리에 적재될 때 프로그램이 프로세스가 되는 것(객체와 인스턴스와 유사)
  
#### 할당받는 자원의 예

* CPU 시간
* 운영되기 위해 필요한 주소 공간
* Code, Data, Stack, Heap의 구조로 되어있는 독립적인 메모리 영역

#### 특징

* 프로세스는 각각의 독립적인 메모리 영역(Code, Data, Stack, Heap의 구조)를 할당
  
  + Code: 프로그램을 실행시키는 실행 파일 내의 명령어(소스코드)
  + Data: 전역변수, static 변수의 할당
  + Heap: 동적할당을 위한 메모리 영역
  + Stack: 지역변수, 함수 호출 시 전달되는 파라미터, 함수 리턴시 리턴 값 및 리턴 주소 

* 각 프로세스는 별도의 주소 공간에서 실행, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음

* 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process Communication)을 사용
  
  + 파이프, 파일, 소켓 등을 사용

#### 상태

![image](https://user-images.githubusercontent.com/94096054/147029587-053207b0-1e5c-4700-b41b-feded48ab36a.png)

* new: 프로세스가 처음 생성 되었을 때
* ready: 프로세서에게 할당 되기를 기다리는 상태
* running: 프로세서에 할당되어 실행되는 상태, CPU자원을 차지하고 있음
* waiting or blocked: 작업이 완료되어 입출력을 기다리는 상태
* terminated: 실행이 종료되어 프로세스 모드가 끝난 상태 


#### 프로세스 제어 블록(PCB)

> 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조

![image](https://user-images.githubusercontent.com/94096054/147029982-c995a75f-5a8a-4c34-8f5a-5a7fecf8a039.png)


+ 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성
+ 프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스의 전환이 발생하면 진행하던 작업을 저장하고 CPU를 받환, 이때의 모든 작업을 PCB에 저장
+ 다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행
-> Context Switching

* 저장되는 정보 
  + PID(프로세스 식별자) : 프로세스 식별 번호
  + Process State(프로세스 상태): new, ready, running, waiting, terminated 등의 상태를 저장
  + Program Counter(PC): 프로세스가 실행할 다음 명령어의 주소
  + CPU 레지스터
  + CPU 스케줄링 정보: 프로세스의 우선순의, 스케줄 큐에 대한 포인터 등
  + 메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보
  + 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  + 회계 정보: 사용된 CPU양과 시간, 시간 제한, 계정 번호 등
  
  
####  프로세스 간 통신(IPC, Interprocess Communication)

> 서로 다른 두 개의 프로세스가 정보를 주고 받는 방식

> 실행중인 다른 프로세스들에게 영향을 주거나 받지 않는 독립적인 프로세스, 다른 프로세스들에게 영향을 주거나 받는 협력적인 프로세스가 존재

> IPC 기법을 통해 협력적인 프로세스들은 데이터와 정보를 교환

* Ex) Pipe, Named Piped, Message Queue, Shared Memory, Memory Map, Socket, Semaphore

* 공유 메모리 시스템

> 기본적으로 프로세스는 서로의 영역에 침범할 수 없지만 프로세스가 이 제약조건을 제거하는 것에 동의하고 공유 영역에 글을 써 정보를 교환하는 방식

> 공유 메모리 세그먼트를 생성하는 프로세스의 주소공간에 위치시켜 통신하고자 하는 다른 프로세스들이 이 세그먼트를 자신의 주소공간에 추가하는 방법으로 사용

> 동시에 공유 버퍼를 접근하는 상황 때문에 동기화를 고려

* 메세지 전달 시스템

> 커널을 통해 메세지를 교환하기 때문에 별도의 코드를 구축할 필요학 없어 구현이 쉽지만 Context Switching이 발생하기 때문에 속도가 느리다는 단점이 존재




#### 스레드

> 한 프로세스 내에서 실행되는 여러 흐름의 단위

![image](https://user-images.githubusercontent.com/94096054/147034600-5aca6826-98c9-4234-8ec7-7ef1a33aaf4e.png)

+ 프로세스의 특정한 수행 경로
+ 프로세스 내의 주소 공간이나 자원 공유(Code, Data, Heap)
+ 스레드 ID, 프로그램 카운터 레지스터 집합, 스택으로 구성 
+ 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상하는 것 -> 멀티 스레딩
+ 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 Stack과 PC 레지스터를 가진다

* 특징

  + 스레드는 프로새스 내에서 각각 Stack과 레지스터를 따로 할당받고, Code, Data, Heap 영역은 공유
  + 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 즉시 확인이 가능

* 분류 
> 권한이 없는 스레드가 시스템 호출을 사용할 수 없도록 막기위해 종류를 나눔

  + 사용자 수준의 스레드(User Threads)
    - 사용자가 만든 라이브러리를 사용하여 스레드를 운용
    - 속도는 빠르지만 구현의 어려움
    - 시스템 호출 권한이 없는 스레드
    - 
  + 커널 수준의 스레드(Kernel Threads)
    - 운영체제 커널에 의해 스레드를 운용
    - 구현은 쉽지만 유저 모드에서 커널 모드로 계속 바꿔줘야 하기 때문에 속도가 느림
    - 시스템 호출 권한이 있는 스레드

#### ???

* 스택을 스레드마다 독립적으로 할당하는 이유:

> 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소 값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간

> 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것 -> 독립적인 실행 흐름의 추가

* PC(프로그램 카운터) 레지스터를 스레드마다 독립적으로 할당하는 이유:

> PC 값은 스레드가 명령어의 어디까지 수행했는지를 보여준다

> 스레드는 CPU를 할당 받았다가 스케줄러에 의해 다시 선점 당하는데, 이때 명령어가 연속적으로 수행되지 못하기 때문에 어느 부분까지 실행되었는지 기록해야 한다


* 스레드 풀(Thread pools)

> 웹 서버는 요청을 받을 때마다 요청을 위해 새로운 스레드를 생성

  + 프로세스를 시작할 때, 일정한 수의 스레드를 미리 풀로 만들어 두는 것
  + 평소에는 기다리다가 요청이 들어오면 풀의 한 스레드에게 서비스를 요청 
  + 요청이 끝나면 스레드는 다시 풀로 돌아가 다음 작업을 대기

* 다중 스레드 서버의 문제점

1. 서비스를 할 때마다 스레드를 생성하는데 시간이 소요

  + 스레드는 주어진 일만 끝나게 되면 곧장 폐기되기 때문에 더욱 낭비

2. 모든 요청마다 새로운 스레드를 만들어 서비스를 한다면 동시에 실행할 수 있는 최대 스레드의 한계를 정해야 한다.

  + 무한정 생성시 CPU 시간, 메모리 공간 등 시스템 자원이 고갈, 웹서버 다운

* 장점

  + 새 스레드를 만들어 주는 것보다 기존 스레드로 서비스 하는 것이 더 빠름
  + 스레드 풀은 임의 시각에 존재할 수 있는 스레드 개수에 제한, 많은 수의 스레드를 병렬 처리할 수 없는 시스템에 도움

* 자바 스레드

  + 일반 스레드와 거의 차이가 없으며 JVM이 운영체제 역할
  + 자바에는 프로세스 단위가 없으며 스레드만 존재
  + 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록
  + 스레드와 관련된 많은 정보들도 JVM에 의해 관리
    - 스레드의 개수
    - 스레드로 실행되는 프로그램 코드의 메모리 위치
    - 스레드의 상태
    - 우선순위 등
  개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행하도록 JVM에 요청
  
#### ??

* 멀티 프로세스 대신 멀티 스레드를 사용하는 이유 

![image](https://user-images.githubusercontent.com/94096054/147038787-530cfba6-03ae-4339-8fc4-0db5b2af78fe.png)

> 프로그램을 여러 개 수행하는 것보다 하나의 프로그램에서 여러 작업을 하는 것

1. 응답성 증가

> 프로그램의 일부분이 봉쇄되거나, 긴 작업을 실행 하더라도 프로그램의 실행이 계속되는 것을 허용함으로써 사용자에 대한 응답성 증가

> Ex) 웹 브라우저는 한 스레드가 이미지 파일을 로드하고 있는 동안 다른 스레드에서 사용자와의 상호작용을 함

2. 자원 공유

> 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능

> 프로세스 간의 Context Switching시 단순히 CPU 레지스터만 교체하는 것이 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화 하기 때문에 오버헤드가 큼

> 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적은 프로세스와 달리 스레드 간에 데이터를 주고 받는 것이 간단해진다. 시스템 자원 소모 감소

> 코드와 데이터를 공유하면 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드 보유 가능

3. 경제성

> 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간의 통신 부담이 감소

> 스레드는 Stack 영역을 제외한 모든 메모리 공유

> 프로세스 생성을 위해 메모리와 자원을 할당하는 것 보다 스레드를 생성하고 문맥교환을 하는 것이 더 경제적

> 프로세스 간의 전환 속도 보다 스레드 간의 전환 속도가 빠름

> Context Switching시 스레드는 Stack 영역만 처리, 캐시 메모리를 비우지 않아도 됨

> 스레드가 프로세스보다 경량이기 때문에 생성과 제거가 쉽다

4. 규모 가변성

> 다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 실행 가능

* 멀티 스레드에서 주의할 점

1. 동기화 문제

  + 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 이용시 충돌 발생 가능
  + 사용 중인 변수나 자료구조에 접근하여 잘못된 값을 읽어오거나 수정할 수 있다.
  + 동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤 해야한다.(병목 현상이 발생할 가능성 있음)

2. 멀티 스레드는 적은 메모리 공간을 차지하고 Context Switching이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료시 전체 스레드가 종료될 수 있다.




#### Context

> CPU가 해당 프로세스를 실행하기 위한 프로세스들의 정보

> 프로세스의 PCB에 저장

#### Context Switching

> 현재 진항하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 상태의 Task의 저장된 상태 값을 읽어 복구하는 작업

> Context Switching이 진행되는 동안 시스템은 아무런 유용한 일도 하지 못하기 때문에 순수한 오버헤드

* Context Switching을 사용하는 이유

  + 하나의 Task만 처리할 수 있다면?
    - 해당 Task가 끝날 때까지 기다려야 한다
    - 반응 속도가 느리고 사용하기 불변하다
  
  + 동시에 사용하는 것처럼 하기 위해
    - Computer Multitasking
    - 빠른 속도로 Task를 바꿔가며 실행하기 때문에 사람의 눈으로는 실시간처럼 보임
    - CPU가 Task를 바꿔가며 실행하기 위해 Context Switching이 필요

* 과정

1. Task의 정보는 Register에 저장되고 PCB로 관리
2. 현재 실항하고 있는 Task의 PCB 정보를 저장(Process Stack, Ready Queue)
3. 다음 실행할 Task의 PCB 정보를 읽어 Registar에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행

  * Cost
    + Cost가 상당히 높음
      - Cache 초기화
      - Memory Mapping 초기화
    
    + Process vs Thead 
      - Thead는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Context Switching 수행 시 Stack 영역만 변경하면 되기 때문에 비용이 적음

#### Thread safe

> 멀티 스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것

* 구현하기
  + 공유자원에 접근하는 임계영역(Critical Section)을 동기화 기법으로 제어 -> 상호 배제
  + 동기화 기법으로는 Mutex, Semaphore이 있음

* Reentrant
> 재진입성, 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장하는 것

> 이를 만족하기 위해 해당 서브루틴에서 공유 자원을 사용하지 않으면 된다.

> 예를 들어 정적, 전역 변수를 사용하거나 반환하면 안되고 호출시 제공된 매개변수만으로 동작해야 함


#### 동기화 객체의 종류

+ 스레드 동기화 방법

1. 실생 순서의 동기화
  * 스레드의 실행 순서를 정의하고, 이 순서에는 반드시 따르도록 하는 것

2. 메모리 접근에 대한 동기화

  * 메모리 접근에 있어서 동시 접근을 막는 것

  * 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황을 의미

* 동기화 기법의 종류

1. 유저 모드 동기화
  
  * 커널의 힘을 빌리지 않는 동기화
  * 성능상 이점, 기능상의 제한
  * ex) 크리티컬 섹션 기반의 동기화, 인터락 함수 기반의 동기화 

2. 커널 모드 동기화

  * 커널에서 제공하는 동기화 기능을 활용하는 방법
  * 커널 모드로의 변경이 필요 -> 성능저하
  * 다양한 기능 활용 가능
  * Ex) 뮤텍스 기반의 동기화, 세마포어 기반의 동기화, 이벤드 기반의 동기화


#### 프로세스 동기화 

* 경쟁 상황(Race Condition)

> 동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 것

> 순서가 달라질 경우 결과 값이 달라짐

> 때문에 동일한 자료에 동시에 접근할 경우 하나의 프로세스만 그 자원에 접근할 수 있도록 보장해야 함

* 임계영역(Critical Section)

> 동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역

* Critical Section Problem(임계영역 문제)
  





























