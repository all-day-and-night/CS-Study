Memory
======

## 메모리 관리 배경

> 각각의 프로세스는 독립된 메모리 공간을 가지고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다.
> 단지, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제한을 받지 않는다.

## Swapping

> 운영체제가 정한 주기마다 스케줄링 정체에 따라 프로세스를 주 메모리에서 보조 메모리로, 다시 보조 메모리에서 주 메모리로 이동시키는 것

* 메모리 관리를 위해 사용되는 기법

  - 표준 Swapping 방식으로는 Round Robin과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를
  - 보조 기억장치(하드디스크)로 내보내고(Swap out) 다른 프로세스의 메모리를 불러 들일 수 있다(Swap in)

## 단편화(Fregmentation)

> 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼 작은 자유 공간들이
> 늘어나게 되는데 이를 단편화라고 한다.

### 외부 단편화(External Fregmentation)
![image](https://user-images.githubusercontent.com/94096054/147093921-20aa9895-3612-4da3-b1eb-9f00f84d856c.png)

> 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생

* 해결방법

  + 압축(compaction): 메모리의 모든 내용을 한 곳으로 몰고 모든 자유 공간들을 다른 한 곳으로 몰아 큰 블록을 만드는 것
    - 재배치가 정적으로 이루어진다면 불가능, 동적으로 재배치가 가능한 경우에만 사용가능
    - 압축 작업 중 시스템은 다른 작업을 할 수 없다.
    - 
  + 통합(Coalscing): 인접한 단편화 영역을 하나의 영역으로 통합하는 작업 

### 내부 단편화(Internal Fregmentation)

 ![image](https://user-images.githubusercontent.com/94096054/147094364-0c4eab52-e706-4dc4-a193-1e383f6ad6c8.png)
 
 
 > 프로세스가 사용하는 공간에 포함된 남는 부분

### 페이징(Paging)

> 가상 메모리를 사용. 외부 단편화 해결

* 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 기법
* 외부 단편화를 방지하고 압축 작업을 불필요하게 함
* 보조 기억장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈 것(페이지), RAM(물리 메모리)을 페이지와 같은 크기로 나눈 것(프레임)
* 사용하지 않는 프레임을 페이지에 옮기고 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
* 페이지와 프레임을 대응시키기 위해 page mapping 과정이 필요해 paging table을 만든다
* 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있어 외부 단편화 문제를 해결 가능
* 코드가 reentrant code라면 공유가 가능(Shared Page)

* 단점
  - 내부 단편화 문제의 비중이 증가
  - 페이지를 작게하면 내부 단편화 문제를 해결할 수 있지만 page mapping table이 많아져 효율이 감소

### 세그멘테이션(Segmentation)
> 가상 메모리를 사용, 내부 단편화 해결 

* 페이징에서 가상 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위(Segmemt)로 분할

* 연속적인 공간에 저장되어 있다
* 세그먼트 테이블에는 각 세그먼트 별 세그먼트 시작 주소와 세그먼트 길이 정보를 가지고 있다

* 단점
  + 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면 
  + 자유 공간들이 많은 수의 작은 조각들로 나누어져 외부 단편화를 일으킨다









 
 
 
 
 
 
 
 
 
 
 
